# Отчет по лабораторной работе №1
# Архитектура СУБД и конфигурации

**Дата:** 2025-11-26  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Степанов Дмитрий Александрович 

## Цель работы
Изучить базовые компоненты архитектуры PostgreSQL (процессы и память) и получить практические навыки управления конфигурационными параметрами сервера на разных уровнях (экземпляр, сеанс). Освоить работу с основными и дополнительными файлами конфигурации, а также с представлениями `pg_settings` и `pg_file_settings`. 

## Теоретическая часть
### 1. Архитектура PostgreSQL
PostgreSQL использует модель «процесс‑на‑подключение»: основной процесс (postmaster / `postgres`) принимает соединения и порождает выделенный backend‑процесс на каждого клиента. Фоновые процессы включают, в частности, `checkpointer`, `background writer (bgwriter)`, `WAL writer`, `archiver`, `autovacuum launcher` и рабочие процессы autovacuum; они совместно обеспечивают сброс грязных страниц, запись и архивирование WAL, автоочистку и анализ статистики. Память разделена на общую (shared) и локальную: shared buffers, WAL buffers, а также per‑session `work_mem`, `maintenance_work_mem` и др. Конфигурация задаёт размеры буферов, стратегию логирования и политики обслуживания. 

**Ключевые источники конфигурации и механизмы применения:**  
- Файлы: `postgresql.conf` (основной), `postgresql.auto.conf` (заполняется `ALTER SYSTEM`), файлы, подключаемые через `include`/`include_dir`, а также `pg_hba.conf` для контроля доступа.   
- Представления: `pg_settings` (текущие значения и происхождение параметров), `pg_file_settings` (что и откуда было прочитано, диагностические ошибки загрузки).   
- Контексты параметров: `postmaster` (требует перезапуска кластера), `sighup` (перечтение конфигурации), `user` (можно менять в сеансе `SET` / в транзакции `SET LOCAL`). 

### 2. Сводка по контекстам и уровням изменения
- **`postmaster`** — изменение вступает в силу **только после рестарта** сервера. Обычно это параметры памяти и системные порты/пути.  
- **`sighup`** — достаточно выполнить `SELECT pg_reload_conf();` либо послать сигнал SIGHUP процессу сервера; используется для логирования и множества runtime‑настроек.  
- **`user`** — можно изменять в рамках сеанса (`SET`) или транзакции (`SET LOCAL`); удобно для временного тюнинга. 

### 3. Основные файлы и их роль
- **`postgresql.conf`** — главный конфигурационный файл сервера.  
- **`postgresql.auto.conf`** — перезаписывается командами `ALTER SYSTEM`; не редактируется вручную.  
- **`conf.d/*.conf`** — подключаемые фрагменты, удобны для тематических групп настроек (например, логирование).  
- **`pg_hba.conf`** — правила аутентификации клиентов (непосредственно не в фокусе данной ЛР, но критичен для доступа).  

## Практическая часть

### Часть 1. Исследование параметров и файлов конфигурации
**Выполненные задачи:**   
1. Подключился к серверу с помощью `psql`. Определил расположение основного файла конфигурации (postgresql.conf) с помощью команды `SHOW config_file;`.  

2. Изучил представление `pg_settings`. Нашёл параметры, для изменения которых требуется перезагрузка сервера (`context = 'postmaster'`). Нашёл 3 параметра с контекстом sighup и user.  

3. Изучил представление `pg_file_settings`. Определил, из каких файлов и с какими значениями были считаны текущие настройки параметров `shared_buffers` и `work_mem`.

**Команды:**

**Задача 1:**
```bash
psql
```
```sql
SHOW config_file;
```

**Задача 2:**
```sql
SELECT name, setting, context
FROM pg_settings
WHERE context = 'postmaster'
ORDER BY name;
```
```sql
SELECT name, setting, context
FROM pg_settings
WHERE context = 'sighup'
ORDER BY name
LIMIT 3;
```
```sql
SELECT name, setting, context
FROM pg_settings
WHERE context = 'user'
ORDER BY name
LIMIT 3;
```

**Задача 3:**
```sql
SELECT *
FROM pg_file_settings
WHERE name IN ('shared_buffers','work_mem');
```

**Фрагменты вывода:** 

**Задача 1:**
```text
psql (16.10 (Ubuntu 16.10-1.pgdg24.04+1))
Type "help" for help.
```
```text
                config_file
-----------------------------------------
 /etc/postgresql/16/main/postgresql.conf
(1 row)
```

**Задача 2:**
```text
              name               |  setting   |  context
---------------------------------+------------+------------
archive_mode                     | off        | postmaster
autovacuum_freeze_max_age        | 200000000  | postmaster
...
```
```text
          name           |  setting   | context
-------------------------+------------+---------
archive_cleanup_command  |            | sighup
archive_command          | (disabled) | sighup
archive_library          |            | sighup
(3 rows)
```
```text
        name         | setting | context
---------------------+---------+---------
application_name     | psql    | user
array_nulls          | on      | user
backend_flush_after  | 0       | user
(3 rows)
```

**Задача 3:**
```text
                    sourcefile                    | sourceline | seqno |      name      | setting | applied | error
--------------------------------------------------+------------+-------+----------------+---------+---------+-------
/etc/postgresql/16/main/postgresql.conf           |        130 |    11 | shared_buffers | 128MB   | t       |
(1 row)
```

---

### Часть 2. Управление параметрами на уровне экземпляра
**Выполненные задачи:**   
1.	Используя команду `ALTER SYSTEM`, установил для параметра `work_mem` новое значение. Убедился, что изменение записалось в файл `postgresql.auto.conf` (использовал функцию `pg_read_file`). Применил изменение, перечитав конфигурацию (`SELECT pg_reload_conf();`). Проверил новое значение параметра и его источник в `pg_settings;`.  

2.	Создал файл `logMin.conf` в каталоге, указанном в директиве `include_dir` основного конфигурационного файла. Установил в этом файле значение для параметра `log_min_duration_statement`. Применил изменение и проверил его.

3.	Намеренно внёс синтаксическую ошибку в один из конфигурационных файлов. Попытался перечитать конфигурацию. Изучил представление `pg_file_settings`, чтобы найти запись об ошибке. Исправил ошибку и перечитал конфигурацию.

**Команды:**

**Задача 1:**
```sql
ALTER SYSTEM SET work_mem = '128MB';
SELECT pg_read_file('postgresql.auto.conf');
```
```sql
SELECT pg_reload_conf();
```
```sql
SELECT name, setting, unit, context, source, sourcefile
FROM pg_settings
WHERE name = 'work_mem';
```

## Результаты выполнения
- Получены и интерпретированы пути к конфигурационным файлам, контексты параметров, источники значений и ошибки загрузки.  
- Демонстрируется корректное применение настроек через `ALTER SYSTEM`, включение конфигурационных фрагментов и диагностика сбоев через `pg_file_settings`. 

## Выводы
1.	Изучил базовые компоненты архитектуры PostgreSQL (процессы, память).

2.	Получил практические навыки управления конфигурационными параметрами сервера на разных уровнях (экземпляр, сеанс).

3.	Освоил работу с основными и дополнительными файлами конфигурации, а также с представлениями pg_settings и pg_file_settings.

## Ответы на контрольные вопросы
**1.	Объясните разницу между контекстами параметров postmaster, sighup и user?**

postmaster – требует перезапуска, sighup – только перечитывания конфигурации, user – может изменяться динамически в рамках сеанса.

**2.	Объясните разницу между применением изменений через ALTER SYSTEM и через SET/SET LOCAL?**

ALTER SYSTEM – системный способ изменения глобальной конфигурации (постоянно).
SET – временное изменение для текущего соединения.
SET LOCAL – временное изменение в рамках одной транзакции.

**3.	Опишите процедуры поиска и исправления ошибки в конфигурационном файл.**

1. Перечитать конфигурацию.

2.	Если в конфигурации есть ошибки, сервер их запишет в системный журнал (postgresql.log) и не применит повреждённые параметры.

3.	Проверить ошибки через системный представления pg_file_settings.

4.	Открыть указанный файл конфигурации и откорректировать значение параметра.

5.	Сохранить файл и перечитать конфигурацию.
